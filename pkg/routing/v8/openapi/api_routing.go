// Code generated by OpenAPI Generator. DO NOT EDIT.
/*
 * Routing API v8
 *
 * A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.
 *
 * API version: 8.3.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package routingv8

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// RoutingApiService RoutingApi service
type RoutingApiService service

// CalculateRoutesOpts Optional parameters for the method 'CalculateRoutes'
type CalculateRoutesOpts struct {
    Via optional.Interface
    DepartureTime optional.String
    RoutingMode optional.Interface
    Alternatives optional.Int32
    Avoid optional.Interface
    Exclude optional.Interface
    Units optional.Interface
    Lang optional.String
    Return_ optional.Interface
    Spans optional.Interface
    Truck optional.Interface
    Ev optional.Interface
    Vehicle optional.Interface
}

/*
CalculateRoutes Calculate routes
Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transportMode Mode of transport to be used for the calculation of the route.
 * @param origin A location defining origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Ask the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. 
 * @param destination A location defining destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Ask the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. 
 * @param optional nil or *CalculateRoutesOpts - Optional Parameters:
 * @param "Via" (optional.Interface of []string) -  A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Ask the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. 
 * @param "DepartureTime" (optional.String) -  Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
 * @param "RoutingMode" (optional.Interface of RoutingMode) -  Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance. 
 * @param "Alternatives" (optional.Int32) -  Number of alternative routes to return aside from the optimal route.
 * @param "Avoid" (optional.Interface of Avoid) -  Avoid routes that violate these properties.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel` 
 * @param "Exclude" (optional.Interface of Exclude) -  Defines properties which will be strictly excluded from route calculation. 
 * @param "Units" (optional.Interface of Units) -  Units of measurement used, for example, in guidance instructions. The default is `metric`.
 * @param "Lang" (optional.String) -  Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). 
 * @param "Return_" (optional.Interface of []Return) -  Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.   * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.     Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified)  * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section.  * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language.  * `summary` - Include summary for the section.  * `travelSummary` - Include summary for the travel portion of the section.  * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section.  * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`  * `routeHandle` - Encode calculated route and return a handle which can be used with    `routes/{routeHandle}` to decode the route at a later point in time. 
 * @param "Spans" (optional.Interface of []Spans) -  Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. 
 * @param "Truck" (optional.Interface of Truck) - 
 * @param "Ev" (optional.Interface of Ev) - 
 * @param "Vehicle" (optional.Interface of Vehicle) - 
@return RouterRouteResponse
*/
func (a *RoutingApiService) CalculateRoutes(ctx _context.Context, transportMode RouterMode, origin string, destination string, localVarOptionals *CalculateRoutesOpts) (RouterRouteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RouterRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/routes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("transportMode", parameterToString(transportMode, ""))
	localVarQueryParams.Add("origin", parameterToString(origin, ""))
	localVarQueryParams.Add("destination", parameterToString(destination, ""))
	if localVarOptionals != nil && localVarOptionals.Via.IsSet() {
		t:=localVarOptionals.Via.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("via", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("via", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.DepartureTime.IsSet() {
		localVarQueryParams.Add("departureTime", parameterToString(localVarOptionals.DepartureTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoutingMode.IsSet() {
		localVarQueryParams.Add("routingMode", parameterToString(localVarOptionals.RoutingMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alternatives.IsSet() {
		localVarQueryParams.Add("alternatives", parameterToString(localVarOptionals.Alternatives.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Avoid.IsSet() {
		localVarQueryParams.Add("avoid", parameterToString(localVarOptionals.Avoid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Exclude.IsSet() {
		localVarQueryParams.Add("exclude", parameterToString(localVarOptionals.Exclude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Units.IsSet() {
		localVarQueryParams.Add("units", parameterToString(localVarOptionals.Units.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Lang.IsSet() {
		localVarQueryParams.Add("lang", parameterToString(localVarOptionals.Lang.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Return_.IsSet() {
		localVarQueryParams.Add("return", parameterToString(localVarOptionals.Return_.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Spans.IsSet() {
		localVarQueryParams.Add("spans", parameterToString(localVarOptionals.Spans.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Truck.IsSet() {
		localVarQueryParams.Add("truck", parameterToString(localVarOptionals.Truck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ev.IsSet() {
		localVarQueryParams.Add("ev", parameterToString(localVarOptionals.Ev.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vehicle.IsSet() {
		localVarQueryParams.Add("vehicle", parameterToString(localVarOptionals.Vehicle.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("apiKey", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetRoutesByHandleOpts Optional parameters for the method 'GetRoutesByHandle'
type GetRoutesByHandleOpts struct {
    DepartureTime optional.String
    Units optional.Interface
    Lang optional.String
    Return_ optional.Interface
    Spans optional.Interface
}

/*
GetRoutesByHandle Get route by handle
Decodes and returns a route from a previously calculated route handle.  **Alpha**: This API is not yet stable and is subject to change.  A route handle encodes a previously calculated route. A route can be decoded from a handle as long the service uses the same map data which was used during encoding.  See also the &#x60;return&#x60; parameter of &#x60;/routes&#x60; endpoint. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param routeHandle Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information. 
 * @param optional nil or *GetRoutesByHandleOpts - Optional Parameters:
 * @param "DepartureTime" (optional.String) -  Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
 * @param "Units" (optional.Interface of Units) -  Units of measurement used, for example, in guidance instructions. The default is `metric`.
 * @param "Lang" (optional.String) -  Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). 
 * @param "Return_" (optional.Interface of []Return) -  Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.   * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.     Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified)  * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section.  * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language.  * `summary` - Include summary for the section.  * `travelSummary` - Include summary for the travel portion of the section.  * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section.  * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`  * `routeHandle` - Encode calculated route and return a handle which can be used with    `routes/{routeHandle}` to decode the route at a later point in time. 
 * @param "Spans" (optional.Interface of []Spans) -  Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. 
@return RouterRouteResponse
*/
func (a *RoutingApiService) GetRoutesByHandle(ctx _context.Context, routeHandle string, localVarOptionals *GetRoutesByHandleOpts) (RouterRouteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RouterRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/routes/{routeHandle}"
	localVarPath = strings.Replace(localVarPath, "{"+"routeHandle"+"}", _neturl.QueryEscape(parameterToString(routeHandle, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DepartureTime.IsSet() {
		localVarQueryParams.Add("departureTime", parameterToString(localVarOptionals.DepartureTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Units.IsSet() {
		localVarQueryParams.Add("units", parameterToString(localVarOptionals.Units.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Lang.IsSet() {
		localVarQueryParams.Add("lang", parameterToString(localVarOptionals.Lang.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Return_.IsSet() {
		localVarQueryParams.Add("return", parameterToString(localVarOptionals.Return_.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Spans.IsSet() {
		localVarQueryParams.Add("spans", parameterToString(localVarOptionals.Spans.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("apiKey", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RoutingErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
